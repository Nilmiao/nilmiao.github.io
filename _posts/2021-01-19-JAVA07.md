---
layout:     post                   
title:      JAVA整理   
subtitle:   Java成长之路(七)
date:       2021-01-19      
author:     MiaoMiaoMiao                   
header-img: img/JAVA01.jpg
catalog: true                       
tags:                               
    - JAVA
---
# Java成长之路七

## 复用

### 如何在不污染代码的前提下使用现存代码；
1. 直接了当；在新类中创建现有类类型的对象，这种方法叫做“组合”(composition)，复用其功能而非形式；
2. 创建现有类型的新类。(采用现有类形式，又无需在编码时改动其代码，这种方法叫做“继承”(Inheritance)，编译器会做大部分工作，继承是面向编程重要基础之一)

### 组合语法
- 只需要把对象的引用(object references)放置在一个新的类里，这就是组合；
- 编译器不会为每个引用创建一个默认对象，这是有意义的。在许多情况下，会导致不必要的开销。

#### 初始化引用的四种方法
1. 当对象被定义时，这意味着它们总是在调用构造函数之前初始化；
2. 在该类的构造函数中；
3. 在实际使用对象之前。 =>延迟初始化，在对象创建开销大且不需要每次都创建对象的情况下，它可以减少开销；
4. 使用实例初始化；

#### 继承语法
- 继承是所有面向对象语言的一个组成部分，事实证明创建类总是要继承的(Object)；
- 使用extends;
- 如果不是用修饰符，成员默认包访问权限，只允许包内成员访问；
- 所以为了继承，一般所有字段为私有，所有方法为公共；
- 继承时，你不受限于使用基类的方法，你可以向类添加任何方法一样额派生类，添加新方法，只需定义它；

#### 初始化基类
- 当你创建派生类的对象时，它包含基类的子对象，这个子对象与你自己创建基类是一样的，只从外部看基类子对象被包装在派生类的对象中。
- 必须正确初始化基类对象，而且只有一种方法可以保证这一点。通过调用基类构造函数中执行初始化。该构造函数具有执行基类初始化所需的所有适当信息和特权；Java自动在派生类构造函数中插入对基类构造函数的调用；
- 构造基类“向外”进行，因此基类在派生类构造函数能够访问它之前进行初始化；

#### 带参数的构造函数
- 如果没有无参数的基本构造函数，或者必须调用具有参数的基类函数，则必须使用super关键字和适当的参数列表，显示地编写对基类构造函数的调用；
- 对基类构造函数的调用必须是派生类构造函数中的第一个操作；

### 委托
- 在Java中不直接支持的第三种重用关系为委托；这介于继承和组合之间。因为你将一个成员对象放在正在构建的类中，但同时又在新类公开来自成员对象的所有方法(比如继承)
- 组合：组合就是A类的对象是B类的成员变量；(Has-a的关系)
- 继承：一个类继承另外的一个类的功能，并可以新增自己的能力；(is-a的关系)

### 保证适当的清理
- 通过在finally子句中放置类清理，防止异常；
- 除了内存够回收之外，不能依赖垃圾收集未做任何事情。如果希望进行清理，可使用自己的清理方法，不是用finalize();

### 名称隐藏
- 如果Java基类的方法多次重载，则派生类中重新定义该方法名不会隐藏任何版本；
- 重写-覆盖同名方法，是用于基类中完全相同的方法签名(方法和参数类型的合称)和返回类型；

### 继承和组合的选择
- 组合与继承都允许在心里诶放置子对象(组合是显式的，而继承是隐式的)
- 当在新类中包含一个已有类的功能时，是用组合，而非继承。在新类中嵌入一个对象(通常是私有的)，以实现其功能，使用者看到的是新类的接口，而非嵌入对象的接口。
- 一种判断使用组合还是继承的最清晰的方法是问一问自己是否需要把新类向上转型为基类；如果必须向上转型，那么继承是必要的。但如果不需要，则要进一步考虑是否该采用继承；

### protected
- 要让一个事物对外界隐藏，而允许派生类的成员访问；
- protected就类的用户而言，这是private的，但对于任何继承它的子类或在同一个包中的类，它是可访问的；

### 向上转型
- 继承保证了基类的所有方法在派生类中也是可用的，所有任意发给该基类消息也发送给派生类；
- 继承中派生类转型为基类是向上的，称之为向上转型，从一个更为具体的类转化成一个更一般的类；所以向上转型是安全的，派生类是基类的一个超集；
- 向上转型接口只会失去方法，不会增加方法；

### final关键字
#### final数据(有些数据是恒定不变的，恒定有用的）
- 一个永不改变的编译时的常量；
- 一个在运行时初始化就不会改变的值；
- 在Java中，这类常量必须是基本类型，而且用关键字final修饰，必须在定义常量时赋值；
- 一个被static和final同事修饰的属性，只会占用一段不能改变的存储空间；
- final修饰对象引用而非基本类型时，其含义会有一点困惑，一旦引用被初始化指向某个对象，它不能改为指向其他对象，但是对象的含义本身就是可以修改的；

#### 空白的final
- 空白的final是没有初始化值的final属性，编译器必须保证空白final在使用前被初始化；
- 你必须在定义时或每个构造器中执行final变量的赋值操作，保证final属性在使用前被初始化；


continue...

![bye](https://i.loli.net/2020/07/18/As9UOXhr8Kl4IQe.png)


